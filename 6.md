## Схема БД

CREATE TABLE Conference (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE);
  
CREATE TABLE Paper(
  id SERIAL PRIMARY KEY,
  title TEXT,
  conference_id INT REFERENCES Conference,
  keywords TEXT[ ],
  accepted BOOLEAN);
  
![код приложения 621 2.06](pics/16.png)

* добавили каталог ключевых слов

![каталог ключевых слов 621 2.45](pics/17.png)

* добавили много конференций

![много конференций 621 3.04](pics/18.png)

* изменение кода приложения при добавлении каталога ключевых слов

![код приложения 621 4.02 4.30 ](pics/19.png)

* код приложения слишком много знал про структуру БД, поэтоме его приходилось менять при каждом изменении схемы БД
* нужно писать код более независимый от структуры БД

## Представления

* виртуальная таблица, тело которой формируется некоторым запросом

пример
![](pics/20.png)

### Функции представления

* настройка схемы БД для разных ролей пользователей
* сокращение текста запросов
* разграничение прав доступа
* **интерфейс к данным:** устойчисвость приложений к изменениям. Если интерфейс представления не меняется, при изменениях в БД достаточно поменять создание представления, не трогая само приложение!

Пример: Поменяли схему БД, поменяли создание представления

![](pics/21.png)


Добавили статью, изменили ключевые слова

![изменение данных 631 0.44](pics/22.png)

Добавили статью

![добавление статьи 631 1.21](pics/23.png)

Изменение ключевых слов

![изменение ключевых слов 631 1.58](pics/24.png)

**Интерфейс операций можно сделать независящим от структуры БД!**

![интерфейс операций 631 2.47](pics/25.png)

## Хранимые процедуры

* определения хранятся в БД
* + выполняются на сервере БД. Нет затрат на пересылку данных между сервером БД и сервером приложения
* + более изощренный контроль над правами доступа
* + меньше шансов на рассинхронизацию кода и данных, т.к. живут вместе
* + приложение получает API для действий над данными
* - синтаксис и поведение плохо стандартизированы (не все производители БД  придерживаются существующих стандартов, есть подводные камни, поведение разное на разных базах)
* - отладка хранимых процедур затруднена (дебаг тяжело делать)
* - код и схема БД в отрыве от приложения => есть шансы, что изменения будут рассинхронизированы. Проблема контроля версий (миграции кода и данных), патчи к коду хранимых процедур
* худший вариант - разбросать по всему коду операторы, читающие и изменяющие данные

пример процедуры submit paper

![пример процедуры submit paper 631 4.20](pics/26.png)

* пример взаимодействие из кода на java

![пример процедуры submit paper 632 1.28](pics/27.png)

## Взаимодействие между приложением и БД

* несоответсвие интерфейсов. Данные таблично-ориентированны, приложение объектно-ориентированно
* низкоуровневые интерфейсы - драйверы для всех основных БД для основных языков программирования
* объектно-реляционные отображения, независящие от конкретной БД. минусы - используется "наибольший общий делитель" всех БД, неиспользуются фичи конкретной БД, которая сейчас используется, либо (для использования большего функционала) дописываются аннотации и конфигурац. файлы
* no sql - старые интерфейсы не работают / работают неэффективно
* Выход: использование собственного интерфейса для доступа к данным

## Независимость от реализации (один из подходов)

![компоненты приложения 643 0.03](pics/28.png)

* **643, 644 - вбить код  и погонять!!!**
* 
