### Схема БД

CREATE TABLE Conference (
  id SERIAL PRIMARY KEY,
  name TEXT UNIQUE);
  
CREATE TABLE Paper(
  id SERIAL PRIMARY KEY,
  title TEXT,
  conference_id INT REFERENCES Conference,
  keywords TEXT[ ],
  accepted BOOLEAN);
  
![код приложения 621 2.06]()

* добавили каталог ключевых слов

![каталог ключевых слов 621 2.45]()

* добавили много конференций

![много конференций 621 3.04]()

* изменение кода приложения при добавлении каталога ключевых слов

![код приложения 621 4.02 4.30 ]()

* код приложения слишком много знал про структуру БД, поэтоме его приходилось менять при каждом изменении схемы БД
* нужно писать код более независимый от структуры БД

## Представления

![изменение данных 631 0.44]()
![добавление статьи 631 1.21]()
![изменение ключевых слов 631 1.58]()
![интерфейс операций 631 2.47]()

### Хранимые процедуры

* определения хранятся в БД
* + выполняются на сервере БД. Нет затрат на пересылку данных между сервером БД и сервером приложения
* + более изощренный контроль над правами доступа
* + меньше шансов на рассинхронизацию кода и данных, т.к. живут вместе
* + приложение получает API для действий над данными
* - синтаксис и поведение плохо стандартизированы (не все производители БД  придерживаются существующих стандартов, есть подводные камни, поведение разное на разных базах)
* - отладка хранимых процедур затруднена (дебаг тяжело делать)
* - код и схема БД в отрыве от приложения => есть шансы, что изменения будут рассинхронизированы. Проблема контроля версий (миграции кода и данных), патчи к коду хранимых процедур
* худший вариант - разбросать по всему коду операторы, читающие и изменяющие данные

![пример процедуры submit paper 631 4.20]()

* пример взаимодействие из кода на java

![пример процедуры submit paper 632 1.28]()

### Взаимодействие между приложением и БД

* несоответсвие интерфейсов. Данные таблично-ориентированны, приложение объектно-ориентированно
* низкоуровневые интерфейсы - драйверы для всех основных БД для основных языков программирования
* объектно-реляционные отображения, независящие от конкретной БД. минусы - используется "наибольший общий делитель" всех БД, неиспользуются фичи конкретной БД, которая сейчас используется, либо (для использования большего функционала) дописываются аннотации и конфигурац. файлы
* no sql - старые интерфейсы не работают / работают неэффективно
* Выход: использование собственного интерфейса для доступа к данным

### Независимость от реализации (один из подходов)

![компоненты приложения 643 0.03]()
![пример Java Persistence API (JPA) 643 2.0]()   посмотреть еще разна видее
![пример Java Persistence API (JPA) 643 2.30]() 
![пример Java Persistence API (JPA) 643 3.02]() 
* 
* 
